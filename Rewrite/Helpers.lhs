Author: Dominic Orchard
License: BSD

Prototype implementation of constraint synonsm and constraint families as described in
"Haskell Type Constraints Unleashed" (Dominic Orchard, Tom Schrijvers)

> module Rewrite.Helpers where

> import Language.Haskell.Exts.Parser
> import Language.Haskell.Exts.Pretty
> import Language.Haskell.Exts.Syntax
> import Language.Haskell.Exts.Extension

Parse our Haskell with the following parsing with the following extensions

> myExtensions :: [Extension]
> myExtensions = [PostfixOperators,
>                 QuasiQuotes,
>                 UnicodeSyntax,
>                 PatternSignatures,
>                 MagicHash,
>                 ForeignFunctionInterface,
>                 TemplateHaskell,
>                 RankNTypes,
>                 MultiParamTypeClasses,
>                 RecursiveDo,
>                 TypeFamilies,
>                 KindSignatures,
>                 FlexibleContexts]

                 ScopedTypeVariables

> myParseHsModule :: String -> Either String Module
> myParseHsModule input = case (parseModuleWithMode myParseMode input) of
>                     ParseOk x -> Right x
>                     ParseFailed _ s -> Left s

> myParseMode = defaultParseMode{extensions = myExtensions}

correctLineNumbers: takes a list of declaration terms paired with a value that 
represents the number of additional lines generated by our transformation- 
this value is then used to correct all other line numbers for output purposes

> correctLineNumbers _ [] = []
> correctLineNumbers cumulative ((d, adjustment):ds) = 
>     (incrementLineNumber cumulative' d):(correctLineNumbers cumulative' ds)
>     where
>       cumulative' = cumulative+adjustment

incrementLineNumber: adds the value x to the line number of a declaration d

> incrementLineNumber x d =
>   case d of
>     TypeDecl s a b c -> TypeDecl (addLineNumber x s) a b c
>     TypeFamDecl s a b c -> TypeFamDecl (addLineNumber x s) a b c
>     DataDecl s a b c d e f -> DataDecl (addLineNumber x s) a b c d e f
>     GDataDecl s a b c d e f g -> GDataDecl (addLineNumber x s) a b c d e f g
>     DataFamDecl s a b c d -> DataFamDecl (addLineNumber x s) a b c d
>     TypeInsDecl s a b -> TypeInsDecl (addLineNumber x s) a b
>     DataInsDecl s a b c d -> DataInsDecl (addLineNumber x s) a b c d
>     GDataInsDecl s a b c d e -> GDataInsDecl (addLineNumber x s) a b c d e
>     ClassDecl s a b c d e -> ClassDecl (addLineNumber x s) a b c d e
>     InstDecl s a b c d -> InstDecl (addLineNumber x s) a b c d
>     DerivDecl s a b c -> DerivDecl (addLineNumber x s) a b c
>     InfixDecl s a b c -> InfixDecl (addLineNumber x s) a b c
>     DefaultDecl s a -> DefaultDecl (addLineNumber x s) a
>     SpliceDecl s a -> SpliceDecl (addLineNumber x s) a
>     TypeSig s a b -> TypeSig (addLineNumber x s) a b
>     FunBind ms -> FunBind (map (addLineNumberMatch x) ms)
>     PatBind s a b c d -> PatBind (addLineNumber x s) a b c d
>     ForImp s a b c d e -> ForImp (addLineNumber x s) a b c d e
>     ForExp s a b c d -> ForExp (addLineNumber x s) a b c d
>     RulePragmaDecl s a -> RulePragmaDecl (addLineNumber x s) a 
>     DeprPragmaDecl s a -> DeprPragmaDecl (addLineNumber x s) a
>     WarnPragmaDecl s a  -> WarnPragmaDecl (addLineNumber x s) a
>     InlineSig s a b c -> InlineSig (addLineNumber x s) a b c
>     SpecSig s a b -> SpecSig (addLineNumber x s) a b
>     SpecInlineSig s a b c d -> SpecInlineSig (addLineNumber x s) a b c d
>     InstSig s a b c -> InstSig (addLineNumber x s) a b c

> addLineNumber x (SrcLoc f n c) = SrcLoc f (n+x) c
> addLineNumberMatch x (Match s a b c d e) = Match (addLineNumber x s) a b c d e

interpretValueAsConstraint: interprets a value term as a constraint term using
a pretty hairy hack: create a module with a single function declaration binding
the rhs of a constraint sym; pretty print the module; strip out everything but the
rhs expression; parse this as a type context, and project out of the qualified type
just the context term. This is a bit ugly because Haskell.Meta doesn't support
pretty printing any terms, only whole modules.

> interpretValueAsConstraint valTerm = 
>          let
>           rhs = UnGuardedRhs valTerm
>           match = Match (SrcLoc "" 1 1) (Ident "reserved") [] Nothing rhs (BDecls [])
>           auxMod = Module (SrcLoc "" 2 1) (ModuleName "aux") [] Nothing Nothing []
>                                     [FunBind [match]]
>           pretty = prettyPrint auxMod
>           justConstraint = tail $ dropWhile ((/=) '=') pretty
>           typeTerm = (parseTypeWithMode myParseMode) (justConstraint ++ "=>a")         
>          in
>            case typeTerm of
>              ParseFailed s err -> error $ "Malformed constraint term at "++(show s)++"\n"++err
>              ParseOk (TyForall _ c _) -> c

              otherwise -> error $ "Malformed constraint term"

interpretTypeAsConstraint: interprets a type term as a constraint term in the same
way as interpreterValueAsConstraint

> interpretTypeAsConstraint typeTerm = 
>          let
>           typeSig = TypeSig (SrcLoc "" 1 1) [(Ident "reserved")] typeTerm
>           auxMod = Module (SrcLoc "" 2 1) (ModuleName "aux") [] Nothing Nothing []
>                                     [typeSig]
>           pretty = prettyPrint auxMod
>           justConstraint = tail $ dropWhile' ((/=) "::") pretty
>           typeTerm' = (parseTypeWithMode myParseMode) (justConstraint ++ "=>a")         
>          in
>            case typeTerm' of
>              ParseFailed s err -> error $ "Malformed constraint term at "++(show s)++"\n"++err
>              ParseOk (TyForall _ c _) -> c

              otherwise -> error $ "Malformed constraint term"

> dropWhile' f [] = []
> dropWhile' f [x] = [x]
> dropWhile' f (x:(y:zs)) = 
>     if f [x,y] then dropWhile' f zs
>     else zs

handles Env of information about constraint families

> type Constructor = String
> type Params = [Type]
> type ClassEnv = [(Constructor, Params)]
> type FunEnv = [(Constructor, [(Constructor, Params)])]
> type FamEnv = [(Constructor, Params, [(Params, Constructor)])]

> type Env = (ClassEnv, FunEnv, FamEnv)

> emptyEnv :: Env
> emptyEnv = ([],[],[])

> addClass :: (Constructor, Params) -> Env -> Env
> addClass (s, p) (c, fun, fam) = ((s, p):c, fun, fam)

> addFamily :: (Constructor, Params) -> Env -> Env
> addFamily (s, p) (c, fun, fam) = (c, fun, (s, p, []):fam)

> addInstance :: Constructor -> (Params, Constructor) -> Env -> Env
> addInstance name (params, cons) (c, fun, fam) =
>              (c, fun, addInstance' name (params, cons) fam)
> addInstance' _ _ [] = []
> addInstance' name (params, cons) (f@(n, p, is):fs) = 
>     (if (name==n) then (n, p, ((params, cons):is))
>     else f):(addInstance' name (params, cons) fs)

> addFun' (Ident c) p e = addFun c p e
> addFun' (Symbol c) p e = addFun c p e
> addFun :: Constructor -> [(Constructor, Params)] -> Env -> Env
> addFun name gadtParams (c, fun, fam) = (c, (name, gadtParams):fun, fam)

> findClass :: Constructor -> Env -> Maybe Params
> findClass c (classes, _, _) = lookup c classes

 findClass _ [] = Nothing
 findClass name ((c@(name', params):cs) = 
     if (name==name') then Just c
     else findClass name cs

> findFunctionGadtParams :: Constructor -> Env -> Maybe [(Constructor, Params)]
> findFunctionGadtParams c (_, funs, _) = lookup c funs

 findFunctionGadtParams'
 findFunctionGadtParams' _ [] = Nothing
 findFunctionGadtParams' name (f@(name', params):fs) =
     if (name==name') then Just f
     else findFunctionGadtParams name fs

> findFamInstances :: Constructor -> Env -> Maybe [(Params, Constructor)]
> findFamInstances c (_, _, fams) = findFamInstances' c fams
> findFamInstances' _ [] = Nothing
> findFamInstances' name (f@(name', _, ps):fs) = 
>     if (name==name') then Just ps
>     else findFamInstances' name fs

> isFamily :: String -> Env -> Bool
> isFamily x (c, fun, fam) = elem x (map fst3 fam)

> fst3 (a, b, c) = a